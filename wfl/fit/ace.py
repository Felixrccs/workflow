import sys
import os
import warnings
import subprocess
import json
import shlex
from pathlib import Path

import ase.io
from ase.stress import voigt_6_to_full_3x3_stress

from wfl.configset import ConfigSet_in
from .utils import get_RemoteInfo

from expyre import ExPyRe
import wfl.scripts


# def prepare_ace_params_and_fit(fitting_configs, ACE_name, params, ref_property_prefix='REF_', skip_if_present=False, 
                            #    run_dir='.', ace_fit_exec=str((Path(wfl.scripts.__file__).parent / 'ace_fit.jl')))

def fit(fitting_configs, ace_fit_params, skip_if_present=False, run_dir='.', 
        ace_fit_exec=str((Path(wfl.scripts.__file__).parent / 'ace_fit.jl').resolve()), dry_run=False, 
        verbose=True, remote_info=None, wait_for_results=True):
    """Runs ace_fit on a a set of fitting configs

    Parameters
    ----------
    fitting_configs: ConfigSet_in
        set of configurations to fit
    ace_fit_params: dict
        dict with all fitting parameters for ACE1pack 
    skip_if_present: bool, default False
        skip fitting if output is already present
    run_dir: str, default '.'
        directory to run in
    ace_fit_exec: str, default "wfl/scripts/ace_fit.jl"
        executable for ace_fit
    dry_run: bool, default False
        do a dry run, which returns the matrix size, rather than the potential name
    verbose: bool, default True
        print verbose output
    remote_info: dict or wfl.pipeline.utils.RemoteInfo, or '_IGNORE' or None
        If present and not None and not '_IGNORE', RemoteInfo or dict with kwargs for RemoteInfo
        constructor which triggers running job in separately queued job on remote machine.  If None,
        will try to use env var WFL_ACE_FIT_REMOTEINFO used (see below). '_IGNORE' is for
        internal use, to ensure that remotely running job does not itself attempt to spawn another
        remotely running job.
    wait_for_results: bool, default True
        wait for results of remotely executed job, otherwise return after starting job

    Returns
    -------
    ace_filename: Path
        path to base of output files, with various suffixes (in formats) added, as well as other files
        generated by ace_fit.jl

    Environment Variables
    ---------------------
    WFL_ACE_FIT_REMOTEINFO: JSON dict or name of file containing JSON with kwargs for RemoteInfo
        contructor to be used to run fitting in separate queued job
    ACE_FIT_JULIA_THREADS: used to set JULIA_NUM_THREADS for ace_fit.jl, which will use julia multithreading (LSQ assembly)
    ACE_FIT_BLAS_THREADS: used by ace_fit.jl for number of threads to set for BLAS multithreading in ace_fit
    """

    # TODO: modify ace_fit_params with correct prop prefixes before calling this function
    # assert isinstance(ref_property_prefix, str) and len(ref_property_prefix) > 0

    # TODO: decide whether to modify all paths with rundir here or before coming to here. Probably here? 
    run_dir = Path(run_dir)
    ace_filename = run_dir / ace_fit_params["ACE_filename"]

    def _read_size(file_base):
        # TODO: shaky to rely on exact format of .size?
        with open(file_base.parent / (file_base.name + '.size')) as fin:
            fields = fin.readline().strip().split()
            return (int(fields[3]), int(fields[5]))

    def _check_output_files(file_base, formats):
        # TODO: update formats depending of whether we need a yace
        for fmt in formats:
            with open(file_base.parent / (file_base.name + fmt)) as fin:
                if fmt == '.json':
                    _ = json.load(fin)
                elif fmt == '.yace':
                    warnings.warn('Cannot parse yace format (can contain dicts with list keys), so just checking its existence')
                    # _ = yaml.safe_load(fin)
                else:
                    raise ValueError(f'Cannot parse ACE file with format {fmt}')

    # TODO: outdated - decide
    # prefix each format by '.' if not there yet
    # formats = [('' if fmt.startswith('.') else '.') + fmt for fmt in formats]

    # return early if fit calculations are done and output files are present (and readable, when that's
    # possible to check)
    if skip_if_present:
        try:
            if dry_run:
                return _read_size(ace_filename)

            # TODO: just check based on whatever format is given
            _check_output_files(ace_filename, [".json"])

            return str(ace_filename)
        except (FileNotFoundError, json.decoder.JSONDecodeError):
            # continue below for actual size calculation or fitting
            pass

    remote_info = get_RemoteInfo(remote_info, 'WFL_ACE_FIT_REMOTEINFO')
    if remote_info is not None and remote_info != '_IGNORE':
        input_files = remote_info.input_files.copy()
        output_files = remote_info.output_files.copy()

        # put configs in memory so they can be staged out easily
        fitting_configs = fitting_configs.in_memory()

        # run dir will contain only things created by fitting, so it's safe to copy the
        # entire thing back as output
        output_files.append(str(run_dir))

        xpr = ExPyRe(name=remote_info.job_name, pre_run_commands=remote_info.pre_cmds, post_run_commands=remote_info.post_cmds,
                      env_vars=remote_info.env_vars, input_files=input_files, output_files=output_files, function=fit,
                      kwargs= {'fitting_configs': fitting_configs, 'ace_fit_params': ace_fit_params,
                               'run_dir': str(run_dir), 'ace_fit_exec': ace_fit_exec,
                               'dry_run': dry_run, 'verbose': verbose, 'remote_info': '_IGNORE'})

        xpr.start(resources=remote_info.resources, system_name=remote_info.sys_name, header_extra=remote_info.header_extra,
                  exact_fit=remote_info.exact_fit, partial_node=remote_info.partial_node)

        if not wait_for_results:
            return None
        results, stdout, stderr = xpr.get_results(timeout=remote_info.timeout, check_interval=remote_info.check_interval)

        sys.stdout.write(stdout)
        sys.stderr.write(stderr)

        # no outputs to rename since everything should be in run_dir
        xpr.mark_processed()

        return results

    run_dir.mkdir(exist_ok=True, parents=True)

    use_params = dict(ace_fit_params)

    # TODO: tag dry run tag at the end of the executable
    # if dry_run:
        # use_params['dry_run'] = None

    # TODO: don't need these 
    ##the code below needs to know an unfortunate amount about the inner workings of ace_fit.jl
    ## here we rely on knowledge of the --outfile_base
    # use_params['outfile_base'] = str(ace_filename)
    # use_params['outfile_format'] = formats

    #  TODO don't need these either - make sure these are taken care of before coming here. 
    # use_params['key'] = [ [k, ref_property_prefix + v] for k,v in [('E', 'energy'), ('F', 'forces'), ('V', 'virial')] ]
    # use_params['_repeat_key'] = True

    # configs need to be in memory so they can be modified with stress -> virial, and safest to
    # have them as a list (rather than using ConfigSet_in.to_memory()) when passing to ase.io.write below
    fitting_configs = list(fitting_configs)

    # TODO: should this be done here? I think so
    # calculate virial from stress, since ASE uses stress but ace_fit.jl only knows about virial
    for at in fitting_configs:
        if ref_property_prefix + 'stress' in at.info:
            stress = at.info[ref_property_prefix + 'stress']
            if len(stress.shape) == 2:
                # 3x3
                at.info[ref_property_prefix + 'virial'] = list((-stress * at.get_volume()).ravel())
            else:
                # Voigt 6-vector
                at.info[ref_property_prefix + 'virial'] = list((-voigt_6_to_full_3x3_stress(stress) * at.get_volume()).ravel())

    # TODO write to whatever is given in the ace_fit_params ??
    # write to file since that's what script needs as input
    fitting_configs_filename = str(run_dir / f'fitting_database.{ACE_name}.extxyz')
    ase.io.write(fitting_configs_filename, fitting_configs)

    # TODO: maybe a better name than "xyz_filename"
    use_params["xyz_filename"] = fitting_configs_filename

    # TODO: write ace_fit_params to file
    ace_fit_params_filename = "params.json"

    # TODO no need anymore!
    # fitting_line = dict_to_ace_fit_string(use_params)

    cmd = f"{ace_fit_exec} --fit-params {ace_fit_params_filename} "
    if dry_run: 
        cmd += "--dry-run "
    # TODO remove the ... .json.stdout, etc
    cmd +=  f"> {ace_filename}.stdout 2> {ace_filename}.stderr "

    if verbose:
        print('fitting command:\n', cmd)

    # TODO: think
    orig_julia_num_threads = (os.environ.get('JULIA_NUM_THREADS', None))
    if 'ACE_FIT_JULIA_THREADS' in os.environ:
        os.environ['JULIA_NUM_THREADS'] = os.environ['ACE_FIT_JULIA_THREADS']

    # this will raise an error if return status is not 0
    # we could also capture stdout and stderr here, but right now that's done by shell
    try:
        subprocess.run(cmd, shell=True, check=True)
    except subprocess.CalledProcessError as e:
        with open(ace_filename.parent / (ace_filename.name + '.stdout')) as fin:
            for l in fin:
                print('STDOUT', l, end='')

        with open(ace_filename.parent / (ace_filename.name + '.stderr')) as fin:
            for l in fin:
                print('STDERR', l, end='')

        print(f"Failure in calling ACE fitting script {ace_fit_exec} with error code:", e.returncode)
        raise e

    # repeat output and error
    with open(ace_filename.parent / (ace_filename.name + '.stdout')) as fin:
        for l in fin:
            print('STDOUT', l, end='')

    with open(ace_filename.parent / (ace_filename.name + '.stderr')) as fin:
        for l in fin:
            print('STDERR', l, end='')

    if dry_run:
        return _read_size(ace_filename)

    # run can fail without raising an exception in subprocess.run, at least make sure that
    # ACE files exist and are readable
    _check_output_files(ace_filename, [".json"])

    if orig_julia_num_threads is not None:
        os.environ['JULIA_NUM_THREADS'] = orig_julia_num_threads
    else:
        try:
            del os.environ['JULIA_NUM_THREADS']
        except KeyError:
            pass

    return ace_filename

